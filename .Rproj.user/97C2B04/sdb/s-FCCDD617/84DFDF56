{
    "collab_server" : "",
    "contents" : "#' Generate the critical path for a collection of related tasks\n#'\n#' @param df A data frame of tasks with columns ID, name, duration, id's of predecessrs (as a comma separated string)\n#' in that order. Name of columns does not matter, only order. Type 'taskdata1' into the console for an example of valid data.\n#' @param gantt Boolean that specifies whether or not to produce a gantt chart of the results.\n#' @param network Boolean that specifies whether or not to produce a network diagram of the results\n#' @param start_date Starting date for the project. Defaults to the current date.\n#' @return A list of results.\n#'\n#' \\itemize{\n#' \\item \\strong{critical_path} The id's of the critical path.\n#' \\item \\strong{results} A data frame representation of the results that can be passed to the 'gantt' function.\n#' \\item \\strong{gantt} Gantt chart if 'gantt' argument is true.\n#' \\item \\strong{duration} The duration of the project in days.\n#' \\item \\strong{end_date} The end date of the project.\n#' \\item \\strong{network} Network diagram if 'network' argument true.\n#' }\n#' @examples\n#' # Use provided sample data\n#' df <- taskdata1\n#'\n#' res <- critical_path(df)\n#'\n#' @export\ncritical_path <- function(df, gantt = F, network = F, start_date = Sys.Date()){\n  data <- df\n  all_tasks <- list()\n  for(i in 1:nrow(data)){\n    id <- to_id(data[i, 1])\n    name <- data[i, 2]\n    duration <- data[i, 3]\n    pred_id <- as.character(data[i, 4])\n    new_Task <- Task$new(id, name, duration, pred_id)\n    text <- sprintf(\"all_tasks <- c(all_tasks, '%s' = new_Task)\", new_Task$id)\n    eval(parse(text = text))\n  }\n\n  ids <- lapply(data[,1], to_id)\n  invisible(lapply(all_tasks, get_successor, full_tasks = all_tasks))\n\n  # Topologically sort the ids\n  adj_list <- make_node_list(all_tasks, ids)\n  graph <- igraph::graph_from_data_frame(adj_list)\n  sorted_ids <- names(igraph::topo_sort(graph = graph))\n\n  # Create source node\n  start_succ_ids <- c()\n  for(task in all_tasks){\n    if(length(task$predecessor_id) == 0){\n      task$predecessor_id <- \"%id_source%\"\n      start_succ_ids <- c(start_succ_ids, task$id)\n    }\n  }\n\n  # Create a sink node\n  end_pred_ids <- \"\"\n  for(task in all_tasks){\n    if(length(task$successor_id) == 0){\n      task$successor_id <- \"%id_sink%\"\n      end_pred_ids <- paste(end_pred_ids, ',', task$id, sep = \"\")\n    }\n  }\n\n  # Add start task and end task to task list\n  start_task <- Task$new(\"%id_source%\", \"%id_source%\", 0, \"\")\n  start_task$successor_id <- start_succ_ids\n  end_task <- Task$new(\"%id_sink%\", \"%id_sink%\", 0, end_pred_ids)\n\n  all_tasks <- c(\"%id_source%\" = start_task, all_tasks, \"%id_sink%\" = end_task)\n  new_ids <- c(\"%id_source%\", sorted_ids, \"%id_sink%\")\n\n  # Perform the walk ahead\n  walk_ahead(all_tasks, new_ids, start_date)\n\n  # Perform the walk back\n  walk_back(all_tasks, new_ids)\n\n  # Prepare the results list\n  ret <- list()\n\n  # Calculate the critical path\n  c_path <- crit_path(new_ids, all_tasks)\n  ret$critical_path <- c_path[c(-1, -length(c_path))]\n  ret$results <- to_data_frame(all_tasks)\n\n  # If gantt is true, add network diagram to results\n  if(gantt){\n    ret$gantt <- gantt(ret)\n  }\n\n  ret$total_duration <- sum((ret$results)[(ret$results)$is_critical,]$duration)\n  ret$end_date <- start_date + ret$total_duration\n  ret$network <- graph\n\n  # If network is true, add network diagram\n  if(network){\n    ret$network_diagram <- network_diagram(ret)\n  }\n\n  ret\n}\n\n#' Creates a Gantt chart of tasks in a project.\n#'\n#' @param df Task input. This can either be a data frame of raw data\n#' (i.e not from the 'critical_path' function) or can the return value from calling\n#' the 'critical path' function.\n#' If the data is raw, if must have columns \"ID, name, duration, dependencies\"\n#' in that order. These columns need not be named but they must be in that order.\n#' Type 'taskdata1' into the console for an example of raw data.\n#' @param start_date Starting date for the project. Defaults to the current date.\n#' @return A gantt chart for the tasks. If data has been processed by the critical path function,\n#' then this gantt chart will color the critical path elements.\n#' @examples\n#' # Use raw example data\n#' data <- taskdata1\n#' # Create a gantt chart using the raw data\n#' gantt(data)\n#'\n#' res <- critical_path(data)\n#'\n#' # Create a second gantt chart using the processed data\n#' gantt(res)\n#'\n#' @export\ngantt <- function(df, start_date = Sys.Date()){\n  raw = F\n\n  # LOOK AT THESE CONDITIONS\n  if(length(ncol(df) > 0)){\n    if(ncol(df) == 4){\n      raw = T\n\n      # Do necesary preprocessing\n\n      data <- df\n      all_tasks <- list()\n      for(i in 1:nrow(data)){\n        id <- to_id(data[i, 1])\n        name <- data[i, 2]\n        duration <- data[i, 3]\n        pred_id <- as.character(data[i, 4])\n        new_Task <- Task$new(id, name, duration, pred_id)\n        text <- sprintf(\"all_tasks <- c(all_tasks, '%s' = new_Task)\", new_Task$id)\n        eval(parse(text = text))\n      }\n\n      ids <- lapply(data[,1], to_id)\n      invisible(lapply(all_tasks, get_successor, full_tasks = all_tasks))\n\n      # Topologically sort the ids\n      adj_list <- make_node_list(all_tasks, ids)\n      graph <- igraph::graph_from_data_frame(adj_list)\n      sorted_ids <- names(igraph::topo_sort(graph = graph))\n\n      # Create source node\n      start_succ_ids <- c()\n      for(task in all_tasks){\n        if(length(task$predecessor_id) == 0){\n          task$predecessor_id <- \"%id_source%\"\n          start_succ_ids <- c(start_succ_ids, task$id)\n        }\n      }\n\n      # Create a sink node\n      end_pred_ids <- \"\"\n      for(task in all_tasks){\n        if(length(task$successor_id) == 0){\n          task$successor_id <- \"%id_sink%\"\n          end_pred_ids <- paste(end_pred_ids, ',', task$id, sep = \"\")\n        }\n      }\n\n      # Add start task and end task to task list\n      start_task <- Task$new(\"%id_source%\", \"%id_source%\", 0, \"\")\n      start_task$successor_id <- start_succ_ids\n      end_task <- Task$new(\"%id_sink%\", \"%id_sink%\", 0, end_pred_ids)\n\n      all_tasks <- c(\"%id_source%\" = start_task, all_tasks, \"%id_sink%\" = end_task)\n      new_ids <- c(\"%id_source%\", sorted_ids, \"%id_sink%\")\n\n      # Perform the walk ahead\n      walk_ahead(all_tasks, new_ids, start_date)\n\n      df <- to_data_frame(all_tasks)\n    }\n  }else if(is.null(df$results)){\n    stop(\"Invalid input, raw input should have 4 columns, processed should have 7\")\n  }else if(ncol(df$results) != 7){\n    stop(\"Invalid input, raw input should have 4 columns, processed should have 7\")\n  }\n\n  if(!raw){\n    df <- df$results\n    if(df[1, \"is_critical\"] == TRUE){\n      cols <- c(\"#41a9f4\", \"#f4424b\")\n    }else{\n      cols <- c(\"#f4424b\", \"#41a9f4\")\n    }\n  }\n\n  # Make dependency labels\n  deps <- c()\n  for(i in 1:nrow(df)){\n    row <- df[i, ]\n    if(trimws(row$pred_id) == \"\"){\n      deps <- c(deps, \"\")\n    }else{\n      deps <- c(deps, paste(\"Depends:\\n\", gsub(\" \", \", \", trimws(row$pred_id))))\n    }\n  }\n\n  dfr <- data.frame(\n    name        = factor(df$id, levels = rev(df$id)),\n    start.date  = as.Date(c(df$start_date)),\n    end.date    = as.Date(c(df$end_date)),\n    critical = c(df$is_critical),\n    deps = deps\n  )\n\n  mdfr <- tidyr::gather(dfr, measure.vars = c(\"start.date\", \"end.date\"))\n\n  # Make labels only show up once\n  for(i in 1:(nrow(mdfr)/2)){\n    mdfr[i, \"deps\"] <- \"\"\n  }\n\n  if(raw){\n    p <- ggplot2::ggplot(mdfr, ggplot2::aes(mdfr$value, mdfr$name)) +\n      ggplot2::geom_line(colour = \"#41a9f4\", size = 8) +\n      ggplot2::geom_text(ggplot2::aes(label = mdfr$deps), hjust = 0, nudge_x = 0.05, size = 3) +\n      ggplot2::xlab(NULL) +\n      ggplot2::ylab(\"Task ID\")\n  }else{\n    duration <- sum(df[df$is_critical, ]$duration)\n    end_date <- start_date + duration\n\n    p <- ggplot2::ggplot(mdfr, ggplot2::aes(mdfr$value, mdfr$name)) +\n      ggplot2::geom_line(ggplot2::aes(colour = mdfr$critical), size = 8) +\n      ggplot2::geom_text(ggplot2::aes(label = mdfr$deps), hjust = 0, nudge_x = 0.05, size = 3) +\n      ggplot2::xlab(NULL) +\n      ggplot2::ylab(\"Task ID\") +\n      ggplot2::scale_x_date(limits = c(start_date, end_date + 1)) +\n      ggplot2::theme(legend.position = \"none\") +\n      ggplot2::scale_color_manual(values = cols)\n  }\n\n  p\n}\n\n#' Creates a network diagram of tasks in a project.\n#'\n#' @param df Task input. This can either be a data frame of raw data\n#' (i.e not from the 'critical_path' function) or can the return value from calling\n#' the 'critical path' function.\n#' If the data is raw, if must have columns \"ID, name, duration, dependencies\"\n#' in that order. These columns need not be named but they must be in that order.\n#' Type 'taskdata1' into the console for an example of raw data.\n#' @return A network diagram for the tasks. If data has been processed by the critical path function,\n#' then this network diagram will color the critical path elements.\n#' @examples\n#' # Use raw example data\n#' data <- taskdata1\n#' # Create a network diagram chart using the raw data\n#' network_diagram(data)\n#'\n#' res <- critical_path(data)\n#'\n#' # Create a second network diagram using the processed data\n#' network_diagram(res)\n#'\n#' @export\nnetwork_diagram <- function(df){\n  raw = F\n\n  # LOOK AT THESE CONDITIONS\n  if(length(ncol(df) > 0)){\n    if(ncol(df) == 4){\n      raw = T\n    }\n  }else if(is.null(df$results)){\n    stop(\"Invalid input, raw input should have 4 columns, processed should have 7\")\n  }else if(ncol(df$results) != 7){\n    stop(\"Invalid input, raw input should have 4 columns, processed should have 7\")\n  }\n\n  if(raw){\n    data <- df\n    all_tasks <- list()\n    for(i in 1:nrow(data)){\n      id <- to_id(data[i, 1])\n      name <- data[i, 2]\n      duration <- data[i, 3]\n      pred_id <- as.character(data[i, 4])\n      new_Task <- Task$new(id, name, duration, pred_id)\n      text <- sprintf(\"all_tasks <- c(all_tasks, '%s' = new_Task)\", new_Task$id)\n      eval(parse(text = text))\n    }\n\n    ids <- lapply(data[,1], to_id)\n    invisible(lapply(all_tasks, get_successor, full_tasks = all_tasks))\n\n    # Topologically sort the ids\n    adj_list <- make_node_list(all_tasks, ids)\n    graph <- igraph::graph_from_data_frame(adj_list)\n    sorted_ids <- names(igraph::topo_sort(graph = graph))\n\n    # Network diagram\n    graph <- igraph::simplify(graph)\n    l <- igraph::layout.reingold.tilford(graph)\n    l[, c(1,2)] <- l[ ,c(2,1)]\n    l[, 1] <- -l[, 1]\n\n    # Clean up network coordinates, making sure a node and its dependency are not on the same level\n    for(i in 1:length(sorted_ids)){\n      for(j in i:length(sorted_ids)){\n        if(igraph::get.edge.ids(graph, c(i,j)) > 0 && l[i, 1] == l[j, 1]){\n          l[j, 1] <- l[j, 1] + 0.4\n          break\n        }\n      }\n    }\n    igraph::V(graph)$color <- \"#41a9f4\"\n    graphics::plot(graph, layout = l, vertex.shape = \"rectangle\", vertex.size = 20, vertex.size2 = 15, edge.arrow.size = 0.65)\n\n  }\n  else{\n    res <- df$results\n    graph <- igraph::simplify(df$network)\n    sorted_ids <- names(igraph::topo_sort(graph = graph))\n    l <- igraph::layout.reingold.tilford(graph)\n    l[, c(1,2)] <- l[ ,c(2,1)]\n    l[, 1] <- -l[, 1]\n\n    for(i in 1:length(igraph::V(graph))){\n      id <- igraph::V(graph)[[i]]$name\n      if(res[res$id == id, \"is_critical\"]){\n        igraph::V(graph)$color[i] <- \"#f4424b\"\n      }else{\n        igraph::V(graph)$color[i] <- \"#41a9f4\"\n      }\n    }\n\n    # Clean up network coordinates, making sure a node and its dependency are not on the same level\n    for(i in 1:length(sorted_ids)){\n      for(j in i:length(sorted_ids)){\n        if(igraph::get.edge.ids(graph, c(i,j)) > 0 && l[i, 1] == l[j, 1]){\n          l[j, 1] <- l[j, 1] + 0.4\n          break\n        }\n      }\n    }\n\n    graphics::plot(graph, layout = l, vertex.shape = \"rectangle\", vertex.size = 20,\n         vertex.size2 = 15, edge.arrow.size = 0.65)\n  }\n  p <- grDevices::recordPlot()\n  p\n}\n",
    "created" : 1501181536927.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "129|27|186|2|\n188|34|190|2|\n192|11|199|2|\n203|23|210|2|\n223|29|225|2|\n",
    "hash" : "3610007945",
    "id" : "84DFDF56",
    "lastKnownWriteTime" : 1502133927,
    "last_content_update" : 1502133927624,
    "path" : "C:/Users/Student/Box Sync/R Critical Path/projmanr/R/critical_path.R",
    "project_path" : "R/critical_path.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 4,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}
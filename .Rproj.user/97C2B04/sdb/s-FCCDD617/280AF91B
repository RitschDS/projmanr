{
    "collab_server" : "",
    "contents" : "library(R6)\nlibrary(plotly)\nlibrary(igraph)\nlibrary(tidyr)\nlibrary(ggplot2)\n\n# Class Defintion ---------------------------------------------------------\n\n\nTask <- R6::R6Class(\"Task\",\n                    public = list(\n                      id = NULL,\n                      name = NULL,\n                      duration = NULL,\n                      predecessor_id = NULL,\n                      successor_id = NULL,\n                      early_start = NULL,\n                      early_finish = NULL,\n                      late_start = NULL,\n                      late_finish = NULL,\n                      slack = NULL,\n                      is_critical = NULL,\n                      start_date = NULL,\n                      end_date = NULL,\n                      initialize = function(id = NA, name = NA, duration = NA, predecessor_id = NA){\n                        self$id <- to_id(id)\n                        self$name <- name\n                        self$duration <- as.numeric(duration)\n                        self$predecessor_id <- unlist(proc_ids(predecessor_id))\n                        self$successor_id <- NULL\n                        self$is_critical <- FALSE\n                        self$early_start <- 0\n                        self$early_finish <- 0\n                        self$late_start <- 0\n                        self$late_finish <- 0\n                        self$slack <- 0\n                      }\n                    )\n)\n\n# Functions ---------------------------------------------------------------\n\n\n# Function to handle reading of processor ids\nproc_ids <- function(ids){\n  ids <- strsplit(ids, \",\")\n  ids <- lapply(ids, trimws)\n  ids <- ids[[1]][ids[[1]] != \"\"]\n  return(list(ids))\n}\n\n# Function to Convert input to R6 class\nread_func <- function(x){\n  id <- to_id(x[1])\n  name <- x[2]\n  duration <- x[3]\n  pred_id <- x[4]\n  new_Task <- Task$new(id, name, duration, pred_id)\n}\n\n# Convert numeric to id usable by the hash map\nto_id <- function(id){\n  id <- trimws(id)\n  return(as.character(id))\n}\n\n# Gets the successor for an activity\nget_successor <- function(task, full_tasks){\n  ret_ids <- NULL\n  task_id <- task$id\n  for(cur_task in full_tasks){\n    if(task_id %in% unlist(cur_task$predecessor_id)){\n      ret_ids <- c(ret_ids, cur_task$id)\n    }\n  }\n  task$successor_id <- ret_ids\n  return(NULL)\n}\n\n# Function to walk ahead\nwalk_ahead <- function(map, ids, start_date = Sys.Date()){\n\n  for(cur in ids){\n    exp <- sprintf(\"map$'%s'\", cur)\n    current_task <- eval(parse(text = exp))\n    if(length(current_task$predecessor_id) == 0){\n      current_task$early_finish <- current_task$early_start + current_task$duration\n      current_task$start_date <- Sys.Date()\n    }else{\n      for(id in current_task$predecessor_id){\n        exp <- sprintf(\"map$'%s'\", id)\n        pred_task <- eval(parse(text = exp))\n        if(is.null(pred_task)){\n          stop(\"Invalid predeccessor id. Using a predeccessor id for a task that does not exist.\")\n        }\n        if(current_task$early_start <= pred_task$early_finish){\n          current_task$early_start <- pred_task$early_finish\n          current_task$start_date <- pred_task$start_date + pred_task$duration\n        }\n      }\n    }\n    current_task$early_finish <- current_task$early_start + current_task$duration\n    current_task$end_date <- current_task$start_date + current_task$duration\n  }\n}\n\n# Function to walk back\nwalk_back <- function(map, ids){\n\n  for(cur in rev(ids)){\n    exp <- sprintf(\"map$'%s'\", cur)\n    current_task <- eval(parse(text = exp))\n    if(length(current_task$successor_id) == 0){\n      current_task$late_finish <- current_task$early_finish\n    }\n    for(id in current_task$successor_id){\n      exp <- sprintf(\"map$'%s'\", id)\n      succ_task <- eval(parse(text = exp))\n      if(current_task$late_finish == 0){\n        current_task$late_finish <- succ_task$late_start\n      }else{\n        if(current_task$late_finish > succ_task$late_start){\n          current_task$late_finish <- succ_task$late_start\n        }\n      }\n    }\n    current_task$late_start <- current_task$late_finish - current_task$duration\n  }\n}\n\n# Calculate the critical path\ncrit_path <- function(ids, map){\n  c_path <- NULL\n\n  for(id in ids){\n    exp <- sprintf(\"map$'%s'\", id)\n    task <- eval(parse(text = exp))\n    if(task$early_finish == task$late_finish && task$early_start == task$late_start){\n      c_path <- c(c_path, task$id)\n      task$is_critical <- TRUE\n    }else{\n      task$is_critical <- FALSE\n    }\n  }\n\n  return(c_path)\n}\n\n# Converts result to data frame for gantt chart\nto_data_frame <- function(tasks){\n  df <- data.frame(id <- character(),\n                   name <- character(),\n                   start_date <- double(),\n                   end_date <- double(),\n                   duration <- double(),\n                   is_critical <- logical(),\n                   pred_id <- character())\n\n  for(task in tasks){\n    if(task$id != \"%id_source%\" && task$id != \"%id_sink%\"){\n      if(task$predecessor_id[1] == \"%id_source%\"){\n        task$predecessor_id <- \"\"\n      }\n      df <- rbind(df, data.frame(id <- task$id,\n                                 name <- task$name,\n                                 start_date <- task$start_date,\n                                 end_date <- task$end_date,\n                                 duration <- task$duration,\n                                 is_critical <- task$is_critical,\n                                 pred_id <- paste(c(task$predecessor_id, \" \"), collapse = \" \"))\n      )\n    }\n  }\n  colnames(df) <- c(\"id\", \"name\", \"start_date\", \"end_date\", \"duration\", \"is_critical\", \"pred_id\")\n  return(df)\n}\n\n# Produces a list to be handled by the graph\nmake_node_list <- function(map, all_ids){\n  ids <- character()\n  successor <- character()\n\n  for(id in all_ids){\n    exp <- sprintf(\"map$'%s'\", id)\n    succ_task <- eval(parse(text = exp))\n    for(id2 in succ_task$successor_id){\n      ids <- c(ids, id)\n      successor <- c(successor, id2)\n    }\n  }\n\n  ret <- data.frame(id = ids,\n                    successor = successor,\n                    stringsAsFactors=FALSE)\n\n  return(ret)\n}\n\n\n\n#' Generate the critical path for a collection of related tasks\n#'\n#' @param df A data frame of tasks with columns ID, name, duration, id's of predecessrs (as a comma separated string)\n#' in that order. Name of columns does not matter, only order. Type 'taskdata1' into the console for an example of valid data.\n#' @param gantt Boolean that specifies whether or not to produce a gantt chart of the results.\n#' @param network Boolean that specifies whether or not to produce a network diagram of the results\n#' @param start_date Starting date for the project. Defaults to the current date.\n#' @return A list of results.\n#'\n#' \\itemize{\n#' \\item \\strong{critical_path} The id's of the critical path.\n#' \\item \\strong{results} A data frame representation of the results that can be passed to the 'gantt' function.\n#' \\item \\strong{gantt} Gantt chart if 'gantt' argument is true.\n#' \\item \\strong{duration} The duration of the project in days.\n#' \\item \\strong{end_date} The end date of the project.\n#' \\item \\strong{network} Network diagram if 'network' argument true.\n#' }\n#' @examples\n#' # Use provided sample data\n#' df <- taskdata1\n#'\n#' res <- critical_path(df)\n#'\n#' @export\ncritical_path <- function(df, gantt = F, network = F, start_date = Sys.Date()){\n  data <- df\n  all_tasks <- list()\n  for(i in 1:nrow(data)){\n    id <- to_id(data[i, 1])\n    name <- data[i, 2]\n    duration <- data[i, 3]\n    pred_id <- as.character(data[i, 4])\n    new_Task <- Task$new(id, name, duration, pred_id)\n    text <- sprintf(\"all_tasks <- c(all_tasks, '%s' = new_Task)\", new_Task$id)\n    eval(parse(text = text))\n  }\n\n  ids <- lapply(data[,1], to_id)\n  invisible(lapply(all_tasks, get_successor, full_tasks = all_tasks))\n\n  # Topologically sort the ids\n  adj_list <- make_node_list(all_tasks, ids)\n  graph <- igraph::graph_from_data_frame(adj_list)\n  sorted_ids <- names(igraph::topo_sort(graph = graph))\n\n  # Create source node\n  start_succ_ids <- c()\n  for(task in all_tasks){\n    if(length(task$predecessor_id) == 0){\n      task$predecessor_id <- \"%id_source%\"\n      start_succ_ids <- c(start_succ_ids, task$id)\n    }\n  }\n\n  # Create a sink node\n  end_pred_ids <- \"\"\n  for(task in all_tasks){\n    if(length(task$successor_id) == 0){\n      task$successor_id <- \"%id_sink%\"\n      end_pred_ids <- paste(end_pred_ids, ',', task$id, sep = \"\")\n    }\n  }\n\n  # Add start task and end task to task list\n  start_task <- Task$new(\"%id_source%\", \"%id_source%\", 0, \"\")\n  start_task$successor_id <- start_succ_ids\n  end_task <- Task$new(\"%id_sink%\", \"%id_sink%\", 0, end_pred_ids)\n\n  all_tasks <- c(\"%id_source%\" = start_task, all_tasks, \"%id_sink%\" = end_task)\n  new_ids <- c(\"%id_source%\", sorted_ids, \"%id_sink%\")\n\n  # Perform the walk ahead\n  walk_ahead(all_tasks, new_ids, start_date)\n\n  # Perform the walk back\n  walk_back(all_tasks, new_ids)\n\n  # Prepare the results list\n  ret <- list()\n\n  # Calculate the critical path\n  c_path <- crit_path(new_ids, all_tasks)\n  ret$critical_path <- c_path[c(-1, -length(c_path))]\n  ret$results <- to_data_frame(all_tasks)\n\n  # If gantt is true, add network diagram to results\n  if(gantt){\n    ret$gantt <- gantt(ret)\n  }\n\n  ret$total_duration <- sum((ret$results)[(ret$results)$is_critical,]$duration)\n  ret$end_date <- start_date + ret$total_duration\n  ret$network <- graph\n\n  # If network is true, add network diagram\n  if(network){\n    ret$network_diagram <- network_diagram(ret)\n  }\n\n  ret\n}\n\n#' Creates a Gantt chart of tasks in a project.\n#'\n#' @param df Task input. This can either be a data frame of raw data\n#' (i.e not from the 'critical_path' function) or can the return value from calling\n#' the 'critical path' function.\n#' If the data is raw, if must have columns \"ID, name, duration, dependencies\"\n#' in that order. These columns need not be named but they must be in that order.\n#' Type 'taskdata1' into the console for an example of raw data.\n#' @param start_date Starting date for the project. Defaults to the current date.\n#' @return A gantt chart for the tasks. If data has been processed by the critical path function,\n#' then this gantt chart will color the critical path elements.\n#' @examples\n#' # Use raw example data\n#' data <- taskdata1\n#' # Create a gantt chart using the raw data\n#' gantt(data)\n#'\n#' res <- critical_path(data)\n#'\n#' # Create a second gantt chart using the processed data\n#' gantt(res)\n#'\n#' @export\ngantt <- function(df, start_date = Sys.Date()){\n  raw = F\n\n  # LOOK AT THESE CONDITIONS\n  if(length(ncol(df) > 0)){\n    if(ncol(df) == 4){\n      raw = T\n\n      # Do necesary preprocessing\n\n      data <- df\n      all_tasks <- list()\n      for(i in 1:nrow(data)){\n        id <- to_id(data[i, 1])\n        name <- data[i, 2]\n        duration <- data[i, 3]\n        pred_id <- as.character(data[i, 4])\n        new_Task <- Task$new(id, name, duration, pred_id)\n        text <- sprintf(\"all_tasks <- c(all_tasks, '%s' = new_Task)\", new_Task$id)\n        eval(parse(text = text))\n      }\n\n      ids <- lapply(data[,1], to_id)\n      invisible(lapply(all_tasks, get_successor, full_tasks = all_tasks))\n\n      # Topologically sort the ids\n      adj_list <- make_node_list(all_tasks, ids)\n      graph <- igraph::graph_from_data_frame(adj_list)\n      sorted_ids <- names(igraph::topo_sort(graph = graph))\n\n      # Create source node\n      start_succ_ids <- c()\n      for(task in all_tasks){\n        if(length(task$predecessor_id) == 0){\n          task$predecessor_id <- \"%id_source%\"\n          start_succ_ids <- c(start_succ_ids, task$id)\n        }\n      }\n\n      # Create a sink node\n      end_pred_ids <- \"\"\n      for(task in all_tasks){\n        if(length(task$successor_id) == 0){\n          task$successor_id <- \"%id_sink%\"\n          end_pred_ids <- paste(end_pred_ids, ',', task$id, sep = \"\")\n        }\n      }\n\n      # Add start task and end task to task list\n      start_task <- Task$new(\"%id_source%\", \"%id_source%\", 0, \"\")\n      start_task$successor_id <- start_succ_ids\n      end_task <- Task$new(\"%id_sink%\", \"%id_sink%\", 0, end_pred_ids)\n\n      all_tasks <- c(\"%id_source%\" = start_task, all_tasks, \"%id_sink%\" = end_task)\n      new_ids <- c(\"%id_source%\", sorted_ids, \"%id_sink%\")\n\n      # Perform the walk ahead\n      walk_ahead(all_tasks, new_ids, start_date)\n\n      df <- to_data_frame(all_tasks)\n    }\n  }else if(is.null(df$results)){\n    stop(\"Invalid input, raw input should have 4 columns, processed should have 7\")\n  }else if(ncol(df$results) != 7){\n    stop(\"Invalid input, raw input should have 4 columns, processed should have 7\")\n  }\n\n  if(!raw){\n    df <- df$results\n    if(df[1, \"is_critical\"] == TRUE){\n      cols <- c(\"#41a9f4\", \"#f4424b\")\n    }else{\n      cols <- c(\"#f4424b\", \"#41a9f4\")\n    }\n  }\n\n  # Make dependency labels\n  deps <- c()\n  for(i in 1:nrow(df)){\n    row <- df[i, ]\n    if(trimws(row$pred_id) == \"\"){\n      deps <- c(deps, \"\")\n    }else{\n      deps <- c(deps, paste(\"Depends:\\n\", gsub(\" \", \", \", trimws(row$pred_id))))\n    }\n  }\n\n  dfr <- data.frame(\n    name        = factor(df$id, levels = rev(df$id)),\n    start.date  = as.Date(c(df$start_date)),\n    end.date    = as.Date(c(df$end_date)),\n    critical = c(df$is_critical),\n    deps = deps\n  )\n\n  mdfr <- tidyr::gather(dfr, measure.vars = c(\"start.date\", \"end.date\"))\n\n  # Make labels only show up once\n  for(i in 1:(nrow(mdfr)/2)){\n    mdfr[i, \"deps\"] <- \"\"\n  }\n\n  if(raw){\n    p <- ggplot2::ggplot(mdfr, ggplot2::aes(x = mdfr$value, y = mdfr$name)) +\n      ggplot2::geom_line(colour = \"#41a9f4\", size = 8) +\n      ggplot2::geom_text(ggplot2::aes(label = mdfr$deps), hjust = 0, nudge_x = 0.05, size = 3) +\n      ggplot2::xlab(NULL) +\n      ggplot2::ylab(\"Task ID\")\n  }else{\n    duration <- sum(df[df$is_critical, ]$duration)\n    end_date <- start_date + duration\n\n    p <- ggplot2::ggplot(mdfr, ggplot2::aes(mdfr$value, mdfr$name)) +\n      ggplot2::geom_line(ggplot2::aes(colour = mdfr$critical), size = 8) +\n      ggplot2::geom_text(ggplot2::aes(label = mdfr$deps), hjust = 0, nudge_x = 0.05, size = 3) +\n      ggplot2::xlab(NULL) +\n      ggplot2::ylab(\"Task ID\") +\n      ggplot2::scale_x_date(limits = c(start_date, end_date + 1)) +\n      ggplot2::theme(legend.position = \"none\") +\n      ggplot2::scale_color_manual(values = cols)\n  }\n\n  p\n}\n\n#' Creates a network diagram of tasks in a project.\n#'\n#' @param df Task input. This can either be a data frame of raw data\n#' (i.e not from the 'critical_path' function) or can the return value from calling\n#' the 'critical path' function.\n#' If the data is raw, if must have columns \"ID, name, duration, dependencies\"\n#' in that order. These columns need not be named but they must be in that order.\n#' Type 'taskdata1' into the console for an example of raw data.\n#' @return A network diagram for the tasks. If data has been processed by the critical path function,\n#' then this network diagram will color the critical path elements.\n#' @examples\n#' # Use raw example data\n#' data <- taskdata1\n#' # Create a network diagram chart using the raw data\n#' network_diagram(data)\n#'\n#' res <- critical_path(data)\n#'\n#' # Create a second network diagram using the processed data\n#' network_diagram(res)\n#'\n#' @export\nnetwork_diagram <- function(df){\n  raw = F\n\n  # LOOK AT THESE CONDITIONS\n  if(length(ncol(df) > 0)){\n    if(ncol(df) == 4){\n      raw = T\n    }\n  }else if(is.null(df$results)){\n    stop(\"Invalid input, raw input should have 4 columns, processed should have 7\")\n  }else if(ncol(df$results) != 7){\n    stop(\"Invalid input, raw input should have 4 columns, processed should have 7\")\n  }\n\n  if(raw){\n    data <- df\n    all_tasks <- list()\n    for(i in 1:nrow(data)){\n      id <- to_id(data[i, 1])\n      name <- data[i, 2]\n      duration <- data[i, 3]\n      pred_id <- as.character(data[i, 4])\n      new_Task <- Task$new(id, name, duration, pred_id)\n      text <- sprintf(\"all_tasks <- c(all_tasks, '%s' = new_Task)\", new_Task$id)\n      eval(parse(text = text))\n    }\n\n    ids <- lapply(data[,1], to_id)\n    invisible(lapply(all_tasks, get_successor, full_tasks = all_tasks))\n\n    # Topologically sort the ids\n    adj_list <- make_node_list(all_tasks, ids)\n    graph <- igraph::graph_from_data_frame(adj_list)\n    sorted_ids <- names(igraph::topo_sort(graph = graph))\n\n    # Network diagram\n    graph <- igraph::simplify(graph)\n    l <- igraph::layout.reingold.tilford(graph)\n    l[, c(1,2)] <- l[ ,c(2,1)]\n    l[, 1] <- -l[, 1]\n\n    # Clean up network coordinates, making sure a node and its dependency are not on the same level\n    for(i in 1:length(sorted_ids)){\n      for(j in i:length(sorted_ids)){\n        if(igraph::get.edge.ids(graph, c(i,j)) > 0 && l[i, 1] == l[j, 1]){\n          l[j, 1] <- l[j, 1] + 0.4\n          break\n        }\n      }\n    }\n    igraph::V(graph)$color <- \"#41a9f4\"\n    graphics::plot(graph, layout = l, vertex.shape = \"rectangle\", vertex.size = 20, vertex.size2 = 15, edge.arrow.size = 0.65)\n\n  }\n  else{\n    res <- df$results\n    graph <- igraph::simplify(df$network)\n    sorted_ids <- names(igraph::topo_sort(graph = graph))\n    l <- igraph::layout.reingold.tilford(graph)\n    l[, c(1,2)] <- l[ ,c(2,1)]\n    l[, 1] <- -l[, 1]\n\n    for(i in 1:length(igraph::V(graph))){\n      id <- igraph::V(graph)[[i]]$name\n      if(res[res$id == id, \"is_critical\"]){\n        igraph::V(graph)$color[i] <- \"#f4424b\"\n      }else{\n        igraph::V(graph)$color[i] <- \"#41a9f4\"\n      }\n    }\n\n    # Clean up network coordinates, making sure a node and its dependency are not on the same level\n    for(i in 1:length(sorted_ids)){\n      for(j in i:length(sorted_ids)){\n        if(igraph::get.edge.ids(graph, c(i,j)) > 0 && l[i, 1] == l[j, 1]){\n          l[j, 1] <- l[j, 1] + 0.4\n          break\n        }\n      }\n    }\n\n    graphics::plot(graph, layout = l, vertex.shape = \"rectangle\", vertex.size = 20,\n                   vertex.size2 = 15, edge.arrow.size = 0.65)\n  }\n  p <- grDevices::recordPlot()\n  p\n}\n# Main Method Code --------------------------------------------------------\n#\ndata <- as.data.frame(read.csv(\"C:/Users/Student/Box Sync/R Critical Path/data/dragonfly.csv\", header = F))\ngantt(data)\n",
    "created" : 1501801131979.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "566130946",
    "id" : "280AF91B",
    "lastKnownWriteTime" : 1502133815,
    "last_content_update" : 1502133815869,
    "path" : "C:/Users/Student/Box Sync/R Critical Path/dev/critical_path_OO.R",
    "project_path" : null,
    "properties" : {
    },
    "relative_order" : 9,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}
{
    "collab_server" : "",
    "contents" : "# Class Defintion ---------------------------------------------------------\n\n\nTask <- R6::R6Class(\"Task\",\n                    public = list(\n                      id = NULL,\n                      name = NULL,\n                      duration = NULL,\n                      predecessor_id = NULL,\n                      successor_id = NULL,\n                      early_start = NULL,\n                      early_finish = NULL,\n                      late_start = NULL,\n                      late_finish = NULL,\n                      slack = NULL,\n                      is_critical = NULL,\n                      start_date = NULL,\n                      end_date = NULL,\n                      initialize = function(id = NA, name = NA, duration = NA, predecessor_id = NA){\n                        self$id <- to_id(id)\n                        self$name <- name\n                        self$duration <- as.numeric(duration)\n                        self$predecessor_id <- unlist(proc_ids(predecessor_id))\n                        self$successor_id <- NULL\n                        self$is_critical <- FALSE\n                        self$early_start <- 0\n                        self$early_finish <- 0\n                        self$late_start <- 0\n                        self$late_finish <- 0\n                        self$slack <- 0\n                      }\n                    )\n)\n\n# Functions ---------------------------------------------------------------\n\n\n# Function to handle reading of processor ids\nproc_ids <- function(ids){\n  ids <- strsplit(ids, \",\")\n  ids <- lapply(ids, trimws)\n  ids <- ids[[1]][ids[[1]] != \"\"]\n  return(list(ids))\n}\n\n# Function to Convert input to R6 class\nread_func <- function(x){\n  id <- to_id(x[1])\n  name <- x[2]\n  duration <- x[3]\n  pred_id <- x[4]\n  new_Task <- Task$new(id, name, duration, pred_id)\n}\n\n# Convert numeric to id usable by the hash map\nto_id <- function(id){\n  id <- trimws(id)\n  return(as.character(id))\n}\n\n# Gets the successor for an activity\nget_successor <- function(task, full_tasks){\n  ret_ids <- NULL\n  task_id <- task$id\n  for(cur_task in full_tasks){\n    if(task_id %in% unlist(cur_task$predecessor_id)){\n      ret_ids <- c(ret_ids, cur_task$id)\n    }\n  }\n  task$successor_id <- ret_ids\n  return(NULL)\n}\n\n# Function to walk ahead\nwalk_ahead <- function(map, ids, start_date = Sys.Date()){\n\n  for(cur in ids){\n    exp <- sprintf(\"map$'%s'\", cur)\n    current_task <- eval(parse(text = exp))\n    if(length(current_task$predecessor_id) == 0){\n      current_task$early_finish <- current_task$early_start + current_task$duration\n      current_task$start_date <- Sys.Date()\n    }else{\n      for(id in current_task$predecessor_id){\n        exp <- sprintf(\"map$'%s'\", id)\n        pred_task <- eval(parse(text = exp))\n        if(is.null(pred_task)){\n          stop(\"Invalid predeccessor id. Using a predeccessor id for a task that does not exist.\")\n        }\n        if(current_task$early_start <= pred_task$early_finish){\n          current_task$early_start <- pred_task$early_finish\n          current_task$start_date <- pred_task$start_date + pred_task$duration\n        }\n      }\n    }\n    current_task$early_finish <- current_task$early_start + current_task$duration\n    current_task$end_date <- current_task$start_date + current_task$duration\n  }\n}\n\n# Function to walk back\nwalk_back <- function(map, ids){\n\n  for(cur in rev(ids)){\n    exp <- sprintf(\"map$'%s'\", cur)\n    current_task <- eval(parse(text = exp))\n    if(length(current_task$successor_id) == 0){\n      current_task$late_finish <- current_task$early_finish\n    }\n    for(id in current_task$successor_id){\n      exp <- sprintf(\"map$'%s'\", id)\n      succ_task <- eval(parse(text = exp))\n      if(current_task$late_finish == 0){\n        current_task$late_finish <- succ_task$late_start\n      }else{\n        if(current_task$late_finish > succ_task$late_start){\n          current_task$late_finish <- succ_task$late_start\n        }\n      }\n    }\n    current_task$late_start <- current_task$late_finish - current_task$duration\n  }\n}\n\n# Calculate the critical path\ncrit_path <- function(ids, map){\n  c_path <- NULL\n\n  for(id in ids){\n    exp <- sprintf(\"map$'%s'\", id)\n    task <- eval(parse(text = exp))\n    if(task$early_finish == task$late_finish && task$early_start == task$late_start){\n      c_path <- c(c_path, task$id)\n      task$is_critical <- TRUE\n    }else{\n      task$is_critical <- FALSE\n    }\n  }\n\n  return(c_path)\n}\n\n# Converts result to data frame for gantt chart\nto_data_frame <- function(tasks){\n  df <- data.frame(id <- character(),\n                   name <- character(),\n                   start_date <- double(),\n                   end_date <- double(),\n                   duration <- double(),\n                   is_critical <- logical(),\n                   pred_id <- character())\n\n  for(task in tasks){\n    if(task$id != \"%id_source%\" && task$id != \"%id_sink%\"){\n      if(task$predecessor_id[1] == \"%id_source%\"){\n        task$predecessor_id <- \"\"\n      }\n      df <- rbind(df, data.frame(id <- task$id,\n                                 name <- task$name,\n                                 start_date <- task$start_date,\n                                 end_date <- task$end_date,\n                                 duration <- task$duration,\n                                 is_critical <- task$is_critical,\n                                 pred_id <- paste(c(task$predecessor_id, \" \"), collapse = \" \"))\n      )\n    }\n  }\n  colnames(df) <- c(\"id\", \"name\", \"start_date\", \"end_date\", \"duration\", \"is_critical\", \"pred_id\")\n  return(df)\n}\n\n# Produces a list to be handled by the graph\nmake_node_list <- function(map, all_ids){\n  ids <- character()\n  successor <- character()\n\n  for(id in all_ids){\n    exp <- sprintf(\"map$'%s'\", id)\n    succ_task <- eval(parse(text = exp))\n    for(id2 in succ_task$successor_id){\n      ids <- c(ids, id)\n      successor <- c(successor, id2)\n    }\n  }\n\n  ret <- data.frame(id = ids,\n                    successor = successor,\n                    stringsAsFactors=FALSE)\n\n  return(ret)\n}\n",
    "created" : 1501179867267.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "38|26|43|0|\n46|25|52|0|\n55|22|58|0|\n61|44|71|0|\n74|58|98|0|\n",
    "hash" : "774469737",
    "id" : "D4E7279A",
    "lastKnownWriteTime" : 1502126611,
    "last_content_update" : 1502130457756,
    "path" : "C:/Users/Student/Box Sync/R Critical Path/projmanr/R/utility_functions.R",
    "project_path" : "R/utility_functions.R",
    "properties" : {
        "tempName" : "Untitled1"
    },
    "relative_order" : 3,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}